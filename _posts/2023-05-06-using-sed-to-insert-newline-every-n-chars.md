---
layout: post
title:  "sed를 이용하여 일정한 길이마다 줄바꿈하여 출력하기"
date:   2023-05-06 17:00:00 +0900
---

아래 글에서 이어지는 내용.

- [셸에서 랜덤한 N바이트를 16진수로 출력하기](https://nooriro.github.io/230414/random-n-bytes-as-hex-string-in-shell)
- [셸에서 `read -n` 명령으로 일정한 글자수마다 줄바꿈하여 출력하기](https://nooriro.github.io/230501/read-n-in-shell)

솔직히 나에게 `sed`는 어렵고, 익숙하지 않아서 피하고 싶은 존재이다. 셸을 다루다 보면 ‘이 문제는 `sed`를 이용하면 해결할 수 있을 것 같다’는 느낌이 오는 순간을 종종 마주하게 된다. 그럴 때마다 나는, 우선 sed를 안 쓰고 해결할 수 있는 방법이 있는지를 본능적으로 먼저 생각해보게 된다. sed를 사용하는 것이 나쁜 방법이어서가 아니라, 문제 상황에 딱 들어맞는 sed 명령어를 찾아내기까지의 과정이 순탄치 않다는 것을 그동안 여러 차례의 경험을 통해 깨닫았기 때문이다. 

셸 프로그래밍의 삼신기를 꼽자면 `grep`, `sed`, 그리고 `awk`가 여기에 해당하지 않을까 싶다. 이들 명령은 각각, 그 명령 안에서(만) 쓰이는 언어의 문법 체계가 있다. 즉, 이들 명령은 각각이 하나의 독립된 언어인 셈이며, 명령에 익숙해지려면 그 언어를 다루는 방법을 따로 익혀야 한다. 그래서 어려울 수밖에 없다. 하지만, 텍스트를 처리할 일이 많은 셸 프로그래밍에서 이들 명령을 마냥 피해갈 수도 없는 노릇이다. 다른 명령으로는 해결하기 어려운 문제가 이들 명령 한 줄로 해결되는 경우가 부지기수다. (물론, 그렇다고 이들 명령이 만능인 것은 아니다.)


## 데이터 파일 만들기

[지난번 글](https://nooriro.github.io/230501/read-n-in-shell)에서는 `read -n` 명령을 `while`문으로 반복 실행하여 텍스트 문자열을 40글자마다 줄바꿈하여 출력하는 것을 다루었다. 이번에는 같은 작업을 `sed`를 이용하여 해 보자. 우선 지난번 글에서 했던 것 처럼 작업에 사용할 더미 데이터 파일들을 만들자. 아래 명령을 실행하면 된다.

```console
$ xxd -l 100 -p -c 100 /dev/urandom 200_w_newline
$ xxd -l 110 -p -c 110 /dev/urandom 220_w_newline
$ tr -d '\n' < 200_w_newline > 200_wo_newline
$ tr -d '\n' < 220_w_newline > 220_wo_newline
```

이들 명령은 지난번 글에서 실행한 명령과 비슷하지만 미묘한 차이가 있다. 짧게 언급하고 넘어가자면, 우선 `xxd`는 위와 같이 입력 파일명뿐만 아니라 **출력 파일명**도 명령행 인수로 지정할 수 있다. 그리고 `tr` 명령에 파일을 입력으로 전달하려면 `cat`명령과 `|`를 쓰는 대신 위와 같이 `<`를 이용하여 **리디렉션**하는 것이 효과적이다.

아무튼, 실행하면 아래와 같이 4개의 파일이 생성된다.

```console
$ ls -l 2*_newline
-rw-r--r-- 1 nooriro nooriro 201 May  6 15:46 200_w_newline
-rw-r--r-- 1 nooriro nooriro 200 May  6 15:46 200_wo_newline
-rw-r--r-- 1 nooriro nooriro 221 May  6 15:46 220_w_newline
-rw-r--r-- 1 nooriro nooriro 220 May  6 15:46 220_wo_newline
```

파일 이름의 규칙은 다음과 같다. 이름만 봐도 각각이 무슨 파일인지 알 수 있다.
- `200_`로 시작하는 파일: 랜덤한 십육진수 문자 200자리의 데이터
- `220_`로 시작하는 파일: 랜덤한 십육진수 문자 220자리의 데이터
- `_w_newline`으로 끝나는 파일: 끝에 개행문자가 덧붙여져 있다
- `_wo_newline`으로 끝나는 파일: 끝에 개행문자가 덧붙여져 있지 않다

각 파일의 내용을 확인하려면 `cat 200_w_newline` 처럼 `cat` 명령을 실행하면 된다.


## `sed`의 가장 기본적인 `s` 명령

구글에서 [add newline at n bytes in shell](https://www.google.com/search?q=add+newline+at+n+bytes+in+shell&newwindow=1) 검색어로 방법을 찾아봤더니 Unix Stack Exchange에 올라온 아래 질문글이 먼저 눈에 들어왔다.
- [How to insert newline characters every N chars into a long string \[duplicate\]](https://unix.stackexchange.com/questions/489775/how-to-insert-newline-characters-every-n-chars-into-a-long-string/489792#489792)
- [How do I insert a space every four characters in a long line?](https://unix.stackexchange.com/questions/5980/how-do-i-insert-a-space-every-four-characters-in-a-long-line/5981#5981)

첫 번째 문서는 한 줄에 출력할 글자수만 다를 뿐 여기서 하려는 것과 같은 질문이고, 두 번째 문서는 첫 번째 문서에 링크된 글인데 질문이 조금 다르다. 이들 문서에 나온 방법을 참고하여 우선 아래와 같은 명령을 생각해보자.
```
sed 's/.\{40\}/&\
/g' filename
```

위 명령에서 작은따옴표(`' '`)로 둘러싸인 부분이 sed script이다. 이 sed 스크립트를 분석해 보자.\
sed의 사용 방법은 구글에서 [sed tutorial](https://www.google.com/search?q=sed+tutorial&newwindow=1) 혹은 [sed manual](https://www.google.com/search?q=sed+manual&newwindow=1) 혹은 [sed 사용 방법](https://www.google.com/search?q=sed+%EC%82%AC%EC%9A%A9+%EB%B0%A9%EB%B2%95&newwindow=1) 등으로 검색하면 많이 나오는데, 그 중에서 나는 [Bruce Barnett이 작성한 sed 튜토리얼](https://www.grymoire.com/Unix/Sed.html)을 주로 참고했다.

- **`s/REGEXP/REPLACEMENT/`**는 **substitute command**(치환 명령)이다. `REGEXP` 패턴을 찾아서 `REPLACEMENT`로 바꾼다. \([참고](https://www.grymoire.com/Unix/Sed.html#uh-1)\)

- 치환 명령의 끝에 붙은 **`g`**는 **global replacement**를 뜻하는 **플래그**이다. g 플래그가 없으면 각각의 줄에서 첫 번째로 매치된 `REGEXP`만 `REPLACEMENT`로 바뀐다. g가 있어야 나머지도 전부 바뀐다. \([참고](https://www.grymoire.com/Unix/Sed.html#uh-6)\)

- **`.\{40\}`**는 ~~개행 문자를 제외한~~ 임의의 문자(`.`) 40개(`\{40\}`)에 매치되는 패턴이다. 수량 지정자(quantifier)에 쓰이는 `{`와 `}`는 저렇게 백슬래시로 이스케이프를 해야 한다. 우리가 흔히 알고 있는 정규식과 이스케이프 방법이 다르므로 유의. \([참고](https://www.grymoire.com/Unix/Regular.html#uh-8)\)

- **`&`**는 `REGEXP`에 매치된 문자열 전체(즉, 찾은 문자열 전체)를 뜻한다. \([참고](https://www.grymoire.com/Unix/Sed.html#uh-3)\)\
참고로, `REGEXP` 안에서 `\(`...`\)`로 캡처한 그룹을 `REPLACEMENT`로 가져올 때에는 `\1`, `\2`, `\3`, ..., `\9`를 사용한다. 그룹 지정에 쓰이는 괄호 `(` `)` 역시 이스케이프를 한다는 것에 유의할 것. \([참고](https://www.grymoire.com/Unix/Sed.html#uh-4)\)

- **`\` 뒤에 바로 줄바꿈이 된 것**은 개행 문자를 뜻한다. 원래 셸 명령행에서 작은따옴표(`' '`)로 둘러싸인 부분은 글자 그대로의 문자열로 취급되며 개행 문자 역시 이스케이프를 필요로 하지 않는다. 하지만 `REPLACEMENT` 안에서 개행 문자를 나타내려면 그 앞에 `\`를 붙여서 이스케이프를 해야 한다.\
(`\n`이 아니라, `\` 뒤에 ‘글자 그대로의 개행문자’이므로 혼동하지 않도록 주의.)\
참고로 `REGEXP` 안에서는 개행 문자를 `\n`으로 나타내야 한다. 굉장히 혼란스럽다. \([참고](https://www.grymoire.com/Unix/Sed.html#uh-nl)\)


## 여러 정규 표현식의 종류

`sed`가 디폴트로 받는 정규식은 **POSIX basic regular expression \(BRE\)**라는 것인데, 여러 명령행 도구에서 이 BRE가 디폴트로 사용된다. \([참고](https://www.grymoire.com/Unix/Regular.html#uh-8)\)\
하지만 앞서 말했듯이 BRE에서는 자주 사용되는 그룹 지정자 `(` `)`와 수량 지정자 `{` `}` 앞에 `\`를 붙여 이스케이프를 해야 한다. 이는 흔히 사용되는 정규표현식의 문법과 달라서 오류를 내기 쉬우며 또한 가독성도 떨어진다.\
뿐만 아니라 BRE는 매우 기본적인 기능만 지원하며 `?` `+` `|` 조차 지원되지 않는다. `?`는 `\{0,1\}`로, `+`는 `\{1,\}`로 대신할 수 있지만 `|`가 지원되지 않는 것은 치명적이다. \([참고1](https://www.regular-expressions.info/posix.html), [참고2](https://en.wikipedia.org/wiki/Regular_expression#Standards)\) GNU grep과 GNU sed에서는 BRE mode에서 확장 문법으로 `\?` `\+` `\|`를 지원하지만 이는 GNU grep/sed에서만 되는 확장 문법일 뿐이다. \([참고](https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/)\)

**POSIX extended regular expression \(ERE\)**라는 것도 있다. ERE는 메타 문자로 사용된 `(` `)` `{` `}`를 이스케이프하지 않으며 BRE보다 많은 기능을 지원한다. 특히, `?` `+` `|`를 지원한다. `grep`에서는 **`-E` 옵션**을, `sed`에서는 **`-E` 또는 `-r` 옵션**을 지정하면 ERE를 사용할 수 있다. \([참고](https://www.grymoire.com/Unix/Sed.html#uh-4a)\)\
[이 Unix Stack Exchange 답변](https://unix.stackexchange.com/questions/145402/regex-alternation-or-operator-foobar-in-gnu-or-bsd-sed/145404#145404)에 의하면, `awk`에서는 디폴트로 ERE를 사용한다고 한다.

하지만 오래 전부터 사실상의 표준으로 통용되어 온 정규표현식은 BRE도 ERE도 아닌 **Perl의 regular expression**이다. (여기서 Perl은 PHP나 Python같은 스크립트 언어이다.) Perl 정규식은 ERE보다도 기능이 더 방대하다. 상당수의 프로그래밍 언어가 이 Perl 정규식을 지원한다고는 하는데, 모든 기능을 동일하게 구현한 것은 아마 없을테고 Perl 정규식의 일부 기능만을 구현했을 것으로 생각된다. (원래 방대한 기능을 100% 동일하게 구현한다는 것은 엄청나게 어려운 일이다.)

**Perl compatible regular expression \(PCRE\)**라는 것도 있다. 이름만 들으면 정규식의 한 종류인 것처럼 들리지만, 사실 이건 Perl의 정규식을 다른 곳에서도 쓸 수 있게 구현한 라이브러리이다. 이것 역시 Perl의 정규식과 100% 같지는 않지만, 아파치, PHP같은 대형 프로젝트에서도 이 PCRE 라이브러리를 사용하고 있다고 하니, 꽤 유명하고 널리 사용되는 라이브러리인 듯 하다.

정규식의 종류에 대해 관심이 생겨서 인터넷에서 정보를 좀 찾아봤는데, 사실 내가 평소에 하는 작업 정도라면 BRE/ERE정도만 잘 익혀서 활용해도 대부분 해결이 가능할 것 같다. 그리고 Perl 정규식은 명령행 도구에서 지원하지 않는 경우가 대부분이라서 셸에서 보편적으로 활용하기는 어렵다. (우분투의 경우만 보더라도, GNU grep은 Perl 정규식을 지원하지만 GNU sed는 이를 지원하지 않는다. 안드로이드의 셸이나 busybox의 경우는 말할 것도 없다.) 아울러, 정규식으로 모든 문제를 해결할 수는 없다는 것도 짚고 넘어가자. 이를테면 XML 파싱 작업을 하려면 XML parser를 사용해야 한다.


## `sed`의 첫 실행과 해결할 문제 확인

다시 원래 하던 얘기로 돌아와서, 일단 위 sed 명령을 4개 파일에 대하여 각각 실행해보자.
```
sed 's/.\{40\}/&\
/g' filename
```

실행해 보면, 4개 중에서 2개만 기대한 대로 실행되는 것을 확인할 수 있다.\
각 파일의 처리 결과를 눈여겨보자.
```console
$ sed 's/.\{40\}/&\
> /g' 200_w_newline
09908c0b5a22ec99b35467d7aaac50e8b5e0322d
d35404c1602fa63aaf44c1a3bf40942933b41406
1ed87da7f968eba4fdced8ff4894709512ed2f24
70387275aafb21cdd1817557c163927342e50716
1d8305c72b4ba8075ca830e51fd2dda8c3316740

$ sed 's/.\{40\}/&\
> /g' 220_w_newline
f62b844fbde0541e6bf29dcdd313d7396a7161ae
0b9a2afe5fd76557fdaab060d803120baef2ea36
9abb2579e6de10c81803fe83bdf7c84d3d25901d
dec3ea988d5a42ce2443d308080368b3a658eba9
56bf4fcc58d1d8e68564624eca322da797c753d2
0b7beb71e5fc01f0d522
$ sed 's/.\{40\}/&\
> /g' 200_wo_newline
09908c0b5a22ec99b35467d7aaac50e8b5e0322d
d35404c1602fa63aaf44c1a3bf40942933b41406
1ed87da7f968eba4fdced8ff4894709512ed2f24
70387275aafb21cdd1817557c163927342e50716
1d8305c72b4ba8075ca830e51fd2dda8c3316740
$ sed 's/.\{40\}/&\
> /g' 220_wo_newline
f62b844fbde0541e6bf29dcdd313d7396a7161ae
0b9a2afe5fd76557fdaab060d803120baef2ea36
9abb2579e6de10c81803fe83bdf7c84d3d25901d
dec3ea988d5a42ce2443d308080368b3a658eba9
56bf4fcc58d1d8e68564624eca322da797c753d2
0b7beb71e5fc01f0d522$
```

지난번 글에서는 처음에 `while read -n 40 line` 루프 안에서 `echo $line`를 반복 실행하여 출력해 보았는데, 일단 그 때의 결과와 비교해 보자.

- 우선 `_w_newline` 쪽은 지난번 글에서 했던 것과 결과가 동일하다.
  - 즉, 전체 글자수가 40의 배수일 때는 맨 끝에 빈 줄이 생겼고 (F)
  - 40의 배수가 아닐 때는 빈 줄이 생기지 않았다. (P)

- 하지만 `_wo_newline` 쪽은 그렇지 않다.
  - 전체 글자수가 40의 배수일 때는 빈 줄이 생기지 않은 것이 지난번과 동일하다. (P)
  - 그러나, 전체 글자수가 40의 배수가 아닐 때 지난번과는 달리 마지막 줄의 데이터 자체는 누락되지 않고 정상 출력 되었으나, 끝에 개행문자가 없어서 줄바꿈되지 않고 마지막 줄 끝 바로 다음에 셸 프롬프트 `$`가 붙어서 출력되었다. (F)

또한 `_w_newline` 쪽과 `_wo_newline` 쪽의 결과만 가지고 양 쪽을 비교해 보면, 정확히 입력 파일의 차이만큼만 출력에서 차이가 생긴 것을 확인할 수 있다.\
무슨 말이냐면, `_w_newline` 쪽의 결과에서 마지막 개행문자 하나만 제거하면 `_wo_newline` 쪽의 결과와 완전히 같아진다. (다르게 표현하자면, `_wo_newline` 쪽의 결과 끝에다 개행문자를 덧붙이면 `_w_newline` 쪽의 결과와 완전히 동일해진다.)


## `220_wo_newline`쪽을 먼저 디버깅해보자

이제 머리를 굴려서 **마지막 개행 문자의 과부족**을 하나씩 **해결**해보자. 우선 `220_wo_newline` 의 문제부터 먼저 해결해보자.\
`200_wo_newline`과 `220_wo_newline`의 결과를 비교해 보면, 일단 아래와 같이 하면 해결될 것 같다.

- 전체 글자 개수가 1개 이상 39개 이하인 줄 끝에 개행 문자를 추가

위 조건에 매치되는 BRE는 `^.\{1,39\}$`이다. 그래서 아래와 같이\(①\) `sed`명령을 실행하면 될 것 같았다.
```
sed 's/.\{40\}/&\
/g; s/^.\{1,39\}$/&\
/' 220_wo_newline
```

하지만 직접 실행해 본 결과는 직전과 동일했다.
```console
$ sed 's/.\{40\}/&\
> /g; s/^.\{1,39\}$/&\
> /' 220_wo_newline
f62b844fbde0541e6bf29dcdd313d7396a7161ae
0b9a2afe5fd76557fdaab060d803120baef2ea36
9abb2579e6de10c81803fe83bdf7c84d3d25901d
dec3ea988d5a42ce2443d308080368b3a658eba9
56bf4fcc58d1d8e68564624eca322da797c753d2
0b7beb71e5fc01f0d522$
```

그러나 아래와 같이\(②\) 실행하면 잘 실행된다.\
(나는 이 사실을 절반 정도는 **우연히** 발견했다. `sed`에서 `$`가 파일의 끝(정확히 말하자면 파일의 마지막 줄)을 나타내는 특수한 맥락이 있는데, 인터넷에서 [이 스택오버플로우 글](https://stackoverflow.com/questions/3434462/print-lines-in-file-from-the-match-line-until-end-of-file/3434563#3434563)을 보고 그 맥락을 떠올리지 못한 채로 — 혹은 글을 제대로 읽지 않은 채로 — `$`가 파일의 끝이라는 문구만 보고 거의 본능적으로 손이 움직여서 실행해 본 것이다. 지금 생각해 보면 완전 엉터리였는데, 이 글을 끝까지 읽으면 이 엉터리 시도가 엄청난 발견의 계기가 되었다는 것을 알게 될 것이다.)
```
sed 's/.\{40\}/&\
/g; s/.\{1,39\}$/&\
/' 220_wo_newline
```
```console
$ sed 's/.\{40\}/&\
> /g; s/.\{1,39\}$/&\
> /' 220_wo_newline
f62b844fbde0541e6bf29dcdd313d7396a7161ae
0b9a2afe5fd76557fdaab060d803120baef2ea36
9abb2579e6de10c81803fe83bdf7c84d3d25901d
dec3ea988d5a42ce2443d308080368b3a658eba9
56bf4fcc58d1d8e68564624eca322da797c753d2
0b7beb71e5fc01f0d522
$
```

도대체 왜 ①처럼 하면 안 되고 ②처럼 하면 되는 것일까? 몇 가지 실험을 통해 확인한 것은, ①과 ② 모두, 두 번째 `s` 명령에서
- `^`는 줄 맨 앞에 매치되는 것이 아니라, 전체 내용의 맨 앞에만 매치되고
- `$`는 줄 맨 끝에 매치되는 것이 아니라, 전체 내용의 맨 끝에만 매치된다는 사실이다.

왜 이렇게 작동하는 것일까? 이에 대한 나의 가설은 다음과 같다.

1. 입력 파일인 `220_wo_newline`은 중간에 줄바꿈이 없는 한 줄짜리 파일이다.
2. 그러므로 `sed`의 첫 번째 `s` 명령이 실행될 때 전체가 한 줄로 취급되는 것에는 이견의 여지가 없다.
3. **첫 번째 `s`명령에 의해** 40글자마다 하나씩, **다섯 개의 개행 문자가 중간에 삽입**되었다.
4. 하지만 첫 번째 `s` 명령에 의해 삽입된 개행 문자는 `sed`가 실행되는 동안 **줄바꿈이라는 특별한 의미를 부여받지 못하고** 두 번째 (이후의) `s` 명령이 실행될 때 **다른 문자와 똑같이 취급된다.**
5. 따라서 두 번째 `s` 명령 실행시에도 전체가 한 줄로 취급된다.
6. 그러므로 두 번째 `s` 명령 실행시 `^`는 전체의 맨 앞에, `$`는 전체의 맨 끝에 매치된다.

전후 과정까지 풀어서 길게 설명했는데, 그 중에서 진짜로 가설에 해당하는 부분은 아래 한 줄 뿐이다.
> `sed` 실행 도중에 삽입된 개행 문자는 `sed`의 실행이 끝날 때까지 줄바꿈이라는 특별한 의미를 부여받지 못한다.


## `sed`의 정규식에서 `.`은 개행 문자에도 매치될까?

한가지 중요한 것을 이야기할 차례다. 나는 방금 전에 메타 문자 `.`은 **개행 문자를 제외한** 모든 문자에 매치된다고 생각하고 있었다. 왜냐하면, 이 글을 쓰기 위해 인터넷 검색을 하던 도중 그렇게 서술된 문서를 눈여겨 보았기 때문이다. 물론, 줄 단위로 텍스트를 처리하는 `sed`의 특성상, 개행 문자가 줄 중간에 등장하는 것은 논리적으로 불가능하다고 생각되었고 따라서 이를 검증할 수 있는 방법 역시 없다고 생각했다. 그래서 해당 서술을 일단 받아들이긴 했지만, 속으로 미심쩍은 생각마저 지울 수는 없었다.

하지만, 위 가설\( `sed` 실행 도중에 삽입된 개행 문자는 `sed`의 실행이 끝날 때까지 줄바꿈이라는 특별한 의미를 부여받지 못한다\)이 참이라고 가정한다면, `sed`의 두 번째 `s`명령을 이용하여 `.`이 정말로 개행 문자가 아닌 문자에만 매치되는지 아니면 개행 문자도 포함하여 모든 문자에 매치되는지를 실험을 통해 확인할 수 있을 것이다.

그런데, 이를 확인하는 것은 단지 호기심을 해결하는 차원의 문제가 아니다. 사실, ②에서 두 번째 `s` 명령에 포함된 정규식 `.\{1,39\}$`은, **`.`이 개행 문자에는 매치되지 않는다는 것을 전제로 하여 작성된 것**이다. 그러므로 만일 `.`이 실제로는 개행 문자에도 매치된다면, ②의 두 번째 `s`명령은 기대한 대로 작동하지 않을 것이므로 다시 검토되어야 한다.


### 부연 설명

이야기가 점점 복잡해진다. ②에서 실행했던 `sed` 명령을 다시 가져와보자. 여기서 첫 번째 `s`부터 `;`앞까지가 **첫 번째 `s`명령**이고, 그 다음 `s`부터 `'`앞까지가 **두 번째 `s`명령**이다.
```
sed 's/.\{40\}/&\
/g; s/.\{1,39\}$/&\
/' filename
```

자, 부연설명을 위해 `sed`의 첫 번째 `s` 명령이 하는 일을 다시 상기해보자. **첫 번째 `s` 명령은 파일의 내용을 앞에서부터 40글자씩 세어 그 바로 뒤에 개행 문자를 삽입하는 것을 반복**한다. 그러므로 개행문자를 포함하지 않는 `_wo_newline` 파일들의 경우,
- (1) 파일의 크기가 40의 배수일 때 (예: `200_wo_newline`) `sed`의 첫 번째 `s` 명령이 실행되면 그 결과는 **마지막이 개행문자로 끝나게 되므로** 원하는 결과를 얻게 된다. 하지만,
- (2) 파일의 크기가 40의 배수가 아닐 때 (예: `220_wo_newline`) `sed`의 첫 번째 `s` 명령이 실행되면 그 결과는 **마지막이 개행문자로 끝나지 않게 되므로** 끝에 개행문자를 덧붙이는 보정작업이 필요하다.

이때 개행문자를 덧붙이는 보정작업은 (2)의 경우에만 선별적으로 적용되고 (1)의 경우에는 적용되지 않아야 한다. 그래서 생각해낸 것이 `.\{1,39\}$`라는 정규식이다. 두 번째 `s`명령에 이 정규식이 들어가면, `$`는 첫 번째 `s`명령의 결과 **맨 끝에** 매치된다. (이것은 가설이 아니라 몇 차례 실험을 통해 확인한 사실이다.) 그러므로,
- 만일 처음에 생각했던 대로 `.`이 개행문자에는 매치되지 않는다면,
  - (1)의 경우는 `.\{1,39\}$`가 첫 번째 `s` 명령의 결과 중 **어디에도 매치되지 않고**
  - (2)의 경우는 `.\{1,39\}$`가 첫 번째 `s` 명령의 결과 중 **마지막 줄 전체에 매치된다**
  
  따라서 두 번째 `s` 명령을, ②에서와 같이 **위 정규식으로 매치된 부분 뒤에 개행 문자를 덧붙이도록 구성**하면 앞서 말한 **선별적인 보정작업**이 깔끔하게 해결된다.

- 그러나 만일 `.`이 개행문자에도 매치된다면, 정규식 `.\{1,39\}$`는 (1)과 (2)의 경우 모두, 개행문자를 포함한 마지막 39개\(이하\)의 문자에 매칭되므로, 두 번째 `s` 명령을 방금 전처럼 구성하게 되면 결과적으로 **맨 끝에 무조건 개행문자가 1개 추가**된다. 이렇게 되면 (2)는 원하는 결과가 되지만 (1)은 끝에 불필요한 빈 줄이 하나 생기게 된다. (참고로 이 결과는 `_w_newline` 파일들에 `sed`의 첫 번째 `s` 명령을 적용한 것과 동일한 결과이다.)    


### 어느 쪽이 사실인지 검증해 보자

그러므로 (1)의 경우(파일의 크기가 40의 배수일 때)에 대해서도 ②에서 실행했던 `sed` 명령을 그대로(즉, 첫 번째와 두 번째 `s` 명령 모두) 실행하여 결과를 확인할 필요가 있다.

첫 번째 `s` 명령만 실행한 것과 비교했을 때,
- 결과가 동일하다면 `.`이 (첫 번째 `s` 명령에 의해 삽입된) 개행문자에는 매치되지 않는 것이며 
- 끝에 빈 줄이 하나 추가된다면 `.`이 (첫 번째 `s` 명령에 의해 삽입된) 개행문자에도 매치되는 것이다.

`200_wo_newline` 에 대해 ②의 `sed` 명령을 실행해 보자.
```
sed 's/.\{40\}/&\
/g; s/.\{1,39\}$/&\
/' 200_wo_newline
```
```console
$ ### 첫 번째 `s` 명령만 실행 (비교를 위해)
$ sed 's/.\{40\}/&\
> /g' 200_wo_newline
09908c0b5a22ec99b35467d7aaac50e8b5e0322d
d35404c1602fa63aaf44c1a3bf40942933b41406
1ed87da7f968eba4fdced8ff4894709512ed2f24
70387275aafb21cdd1817557c163927342e50716
1d8305c72b4ba8075ca830e51fd2dda8c3316740
$
$ ### 첫 번째와 두 번째 `s` 명령을 모두 실행
$ sed 's/.\{40\}/&\
> /g; s/.\{1,39\}$/&\
> /' 200_wo_newline
09908c0b5a22ec99b35467d7aaac50e8b5e0322d
d35404c1602fa63aaf44c1a3bf40942933b41406
1ed87da7f968eba4fdced8ff4894709512ed2f24
70387275aafb21cdd1817557c163927342e50716
1d8305c72b4ba8075ca830e51fd2dda8c3316740

$
```

위와 같이 끝에 빈 줄이 추가되었다. 그러므로 다음을 확인할 수 있다.
- `.`은 (이전 단계의 `s` 명령에 의해 추가된) **개행문자에도 매치된다.**
- 그러므로 두 번째 `s` 명령의 정규식 `.\{1,39\}$`는, 첫 번째 `s` 명령의 결과 내용 맨 끝부터, 개행문자까지 포함해서 (최대) 39글자에 매치된다.
- 이때 위 정규식은 파일의 길이(40의 배수 여부)를 따지지 않고 끝 부분에 무조건 매치된다는 사실이 중요하다.
- 한편 두 번째 `s` 명령은 위 정규식에 의해 매치된 부분 뒤에 개행문자 1개를 추가하므로
- 결과적으로 **두 번째 `s` 명령은**, 첫 번째 `s` 명령의 결과 **끝에 무조건 개행문자 1개를 추가한다.** 

참고삼아 덧붙이자면, 다른 방법으로도 `.`이 개행 문자에 매치되는지 여부를 확인할 수 있다. 실제로 나는 `.`이 개행문자에도 매치된다는 사실을 다른 방법으로 먼저 확인했다. 하지만 글이 길어졌으므로 다른 확인 방법에 대한 소개는 생략하도록 하겠다.

## 그렇다면 어떻게 해야 하는가

먼 길을 돌고 돌아 확인한 것은, 결국, 두 번째 `s` 명령은 첫 번째 `s` 명령의 결과 끝에 **개행문자를 무조건 1개 추가**한다는 것이다. 그렇다면 지금까지 한 고생은 헛고생일까?

전혀 그렇지 않다. 만일 그렇다고 생각한다면, 지금까지 했던 논의를 완전히 놓친 것이다.

왜 그렇게 되는지를 다시 생각해 보자. 개행문자가 무조건 1개 추가되는 원인은 바로, **`.`이 개행문자에도 매치되기 때문**이다. 그러므로 ②의 두 번째 `s`명령에서 **명시적으로 개행문자가 아닌 문자 1개 이상 39개 이하에 매치되도록** 정규식을 수정하면 이 문제는 쉽게 해결된다.

나는 이 글의 앞부분에서 `sed`의 첫 번째 `s` 명령을 분석하면서, `s/REGEXP/REPLACEMENT/`라는 `s` 명령의 형식에서 `REGEXP` 자리에는 개행문자를 `\n`으로 기술해야 한다는 언급을 한 적이 있다. 그 부분을 작성할 당시에는, 그것이 이 글의 뒷부분에서 쓰일 것이라고는 전혀 생각치 않았다. 하지만 이제 상황이 달라졌다. 여기까지 오기 위해 일부러 빌드업을 한 것은 아니었지만, 결과적으로 해당 사실은 이 문제를 해결하기 위해 꼭 필요한, 없어서는 안 될 정보가 된 것이다.

그 정보를 이용하여, 두 번째 `s` 명령의 정규식 `.\{1,39\}$`에서, **개행 문자도 포함하는 모든 문자**를 의미하는 `.`을, **개행 문자를 제외한 모든 문자**를 의미하는 `[^\n]`으로 바꾸기만 하면 되는 것이다. (참고로 이같은 정규식의 문법을 [negated character class](https://www.google.com/search?q=negated+character+class&newwindow=1)라고 한다.)

수정된 전체 `sed` 명령(③)은 아래와 같다.
```
sed 's/.\{40\}/&\
/g; s/[^\n]\{1,39\}$/&\
/' filename
```
위 명령을 `200_wo_newline`과 `220_wo_newline`에 대하여 실행해보자. 결과는 다음과 같다.
```console
$ sed 's/.\{40\}/&\
> /g; s/[^\n]\{1,39\}$/&\
> /' 200_wo_newline
09908c0b5a22ec99b35467d7aaac50e8b5e0322d
d35404c1602fa63aaf44c1a3bf40942933b41406
1ed87da7f968eba4fdced8ff4894709512ed2f24
70387275aafb21cdd1817557c163927342e50716
1d8305c72b4ba8075ca830e51fd2dda8c3316740
$ sed 's/.\{40\}/&\
> /g; s/[^\n]\{1,39\}$/&\
> /' 220_wo_newline
f62b844fbde0541e6bf29dcdd313d7396a7161ae
0b9a2afe5fd76557fdaab060d803120baef2ea36
9abb2579e6de10c81803fe83bdf7c84d3d25901d
dec3ea988d5a42ce2443d308080368b3a658eba9
56bf4fcc58d1d8e68564624eca322da797c753d2
0b7beb71e5fc01f0d522
$
```

빙고! 바로 이거다. 이로써 `_wo_newline` 쪽에 대한 디버깅이 끝났다.


## `200_w_newline`쪽도 디버깅해보자

이어서 `_w_newline`쪽도 디버깅해보자. 이쪽의 문제점은 **데이터의 길이가 40의 배수**인 `200_w_newline` 파일의 처리 결과 **끝에 빈 줄이 하나 생긴다**는 것이다.

구글에서 [sed delete empty line](https://www.google.com/search?q=sed+delete+empty+line&newwindow=1)이라고 검색해 보면 나오는 방법들은 대부분, `sed`명령을 **처음 실행하는 것을 전제로 하여 짜여진 명령**이다. 그러한 명령을 sed script의 두 번째 `s` 명령으로 넣게 되면 기대한 대로 작동하지 않는다는 것을 우리는 앞에서 이미 보았다. (①의 명령을 참고)

하지만 지금까지 `_wo_newline`쪽을 디버깅하면서 얻은 **노하우**가 있으므로, 굳이 방법을 인터넷에서 찾지 않아도 해결할 수 있을 것 같다. 첫 번째 `s` 명령에 의해 **내용 맨 끝에 개행문자가 삽입되었다면 그걸 제거**하면 된다. 즉, 이번에는 두 번째 `s` 명령을 `s/\n$//`라고 하면 된다. 전체 `sed` 명령(④)은 다음과 같다.
```
sed 's/.\{40\}/&\
/g; s/\n$//' filename
```

`200_w_newline` 파일과 `220_w_newline` 파일에 대해 실행 결과는 다음과 같다.
```console
$ sed 's/.\{40\}/&\
> /g; s/\n$//' 200_w_newline
09908c0b5a22ec99b35467d7aaac50e8b5e0322d
d35404c1602fa63aaf44c1a3bf40942933b41406
1ed87da7f968eba4fdced8ff4894709512ed2f24
70387275aafb21cdd1817557c163927342e50716
1d8305c72b4ba8075ca830e51fd2dda8c3316740
$ sed 's/.\{40\}/&\
> /g; s/\n$//' 220_w_newline
f62b844fbde0541e6bf29dcdd313d7396a7161ae
0b9a2afe5fd76557fdaab060d803120baef2ea36
9abb2579e6de10c81803fe83bdf7c84d3d25901d
dec3ea988d5a42ce2443d308080368b3a658eba9
56bf4fcc58d1d8e68564624eca322da797c753d2
0b7beb71e5fc01f0d522
$
```
빙고! 앞에서 고생한 덕분에 `_w_newline` 쪽 문제도 금방 해결할 수 있었다.


## 마무리하며

이 글은 ②의 `sed` 명령을 발견한 직후부터 쓰기 시작했다. 당시 나는 그걸로 문제를 해결했다고 생각했고, 따라서 ②에 이르는 과정까지만 정리하면 쉽게 글이 쓰여질 것이라고 생각했다. 하지만 글을 쓰던 도중에 ②가 해결책이 아니라는 것을 알게 되어 멘붕에 빠졌다. 이런 저런 실험들과 글 쓰기를 병행하느라 머리속은 뒤죽박죽이 되었다.

글을 쓰다가 나조차도 머리속이 하얘지는 경험을 하여 쓰던 글의 뒷부분을 날리고, 지금까지의 논리 흐름을 부연 설명으로 다시 정리하는 내용을 추가했다. 이런 복잡한 논리를 오로지 텍스트로만 설명한다는 것은 정말 쉽지 않다는 것을 뼈저리게 느꼈다. 만약에 명령의 실행 결과를 큰 화면에 띄워놓고, 화이트보드에 그림을 그려 가면서 말로 설명을 할 수 있었다면, 말하는 쪽이나 듣는 쪽이나 모두 좀 더 이해하기 수월했을 것이다. 하지만 전체 논리의 흐름이 내 머리속에 완전히 정리되었는지 그렇지 않은지가 사실 더 중요한 문제다. 내 머리 속이 뒤죽박죽이면 그걸 말로 하건 글로 풀어내건 어느 쪽이든 뒤죽박죽이 될 수밖에 없다.  

책이든 튜토리얼이든, 교과서 스타일로 방대한 내용을 처음부터 하나씩 설명하는 글은 무작정 읽다보면 금방 지치고 머리속에도 잘 안 들어온다. 하지만 이렇게 특별한 계기로 인해 고생 끝에 알아낸 노하우는 어지간해서 잘 잊혀지지 않는다. 이번에는 ②의 실행이 그 특별한 계기가 되었다. ② 자체가 해결책은 아니었지만, ②의 문제를 확인하고 보완하는 과정에서 알게 된 지식들은 ②가 아니었다면 발견하지 못했을 지도 모른다. 그만큼 특별하고 소중한 경험이었다고 나는 생각한다.

